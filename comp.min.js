/* ____ ____ _  _ ___   
*  |___ [__] |\/| |--' . v1.10.0
* 
* A design pattern and micro-framework for creating UI components
*
* Copyright Brendan Jefferis and other contributors
* Released under the MIT license
* 
* Issues? Please visit https://github.com/brendan-jefferis/comp/issues
*
* Date: 2017-05-01T09:54:54.230Z 
*/
(function(e,n){typeof exports==="object"&&typeof module!=="undefined"?module.exports=n():typeof define==="function"&&define.amd?define(n):e.comp=n()})(this,function(){"use strict";function e(e){try{new Function(e)}catch(e){if(e instanceof SyntaxError){throw new SyntaxError(e)}}}function n(e){e=e||window.event;return e.target||e.srcElement}/* eslint-disable no-nested-ternary */
var t=[];var r=[];var o=function(e,n){if(e===n){return 0}var o=e;
// Swapping the strings if `a` is longer than `b` so we know which one is the
// shortest & which one is the longest
if(e.length>n.length){e=n;n=o}var i=e.length;var a=n.length;if(i===0){return a}if(a===0){return i}
// Performing suffix trimming:
// We can linearly drop suffix common to both strings since they
// don't increase distance at all
// Note: `~-` is the bitwise way to perform a `- 1` operation
while(i>0&&e.charCodeAt(~-i)===n.charCodeAt(~-a)){i--;a--}if(i===0){return a}
// Performing prefix trimming
// We can linearly drop prefix common to both strings since they
// don't increase distance at all
var u=0;while(u<i&&e.charCodeAt(u)===n.charCodeAt(u)){u++}i-=u;a-=u;if(i===0){return a}var f;var c;var l;var d;var s=0;var v=0;while(s<i){r[u+s]=e.charCodeAt(u+s);t[s]=++s}while(v<a){f=n.charCodeAt(u+v);l=v++;c=v;for(s=0;s<i;s++){d=f===r[u+s]?l:l+1;l=t[s];c=t[s]=l>c?d>c?c+1:d:d>l?l+1:d}}return c};var i=3;function a(e,n){if(e==null){throw new Error("suggestActions requires a string argument to use as a query")}if(n==null){throw new Error("suggestActions requires a component to search for actions")}var t=[];Object.keys(n).map(function(n){var r=o(e,n);if(r>i){return}t.push({term:n,distance:r})});return t.sort(function(e,n){return e.distance>n.distance})}function u(e){["mousedown","mouseup","mouseover","mouseout","mousemove","mousedrag","click","dblclick","keydown","keyup","keypress","focus","blur","select","change","dragdrop","drag","dragstart","dragend","dragover","dragenter","dragleave","dragexit","drop"].map(function(n,t){if(t>=4&&t<=19){document.body.addEventListener(n.toLowerCase(),function(n){f(n,e)})}},this)}function f(e,t){e.stopPropagation();var r=n(e);if(r.nodeName==="BODY"){return}var o=l(r);if(o==null){return}var i=t[o.getAttribute("data-component")];var u=d(e,r,o);if(u.name===""){return}if(i[u.name]==null){var f=a(u.name,i);var c=f.length?"\r\n\r\nDid you mean\r\n\r\n"+f.map(function(e){return i.name+"."+e.term+"\n"}).join("")+"\r":"";throw new Error("Could not find action "+u.name+" in component "+i.name+c)}if(u.args===""){i[u.name].call(u,e)}else{i[u.name].apply(u,u.args.concat(e))}var s=new Event("comp_action");o.dispatchEvent(s);document.dispatchEvent(s)}function c(n,t,r){var o=t.getAttribute("data-"+[n.type])||"";if(o!==""||t===r){try{e(o,t)}catch(e){var i=document.createElement("div");i.appendChild(t.cloneNode(false));throw new SyntaxError("\r\n\r\nElement: "+i.innerHTML+"\r\nEvent: data-"+[n.type]+"\r\nAction: "+o+"\r\n\r\n"+e)}return{name:o,element:t}}return c(n,t.parentNode,r)}function l(e){return e.closest("[data-component]")}function d(e,n,t){var r=c(e,n,t);return{name:s(r.name),args:v(r.name,r.element)}}function s(e){var n=e.match(/[^(]*/);return n?n[0]:""}function v(e,n){var t=/\(\s*([^)]+?)\s*\)/.exec(e);if(!t||t[1]==null){return""}t=t[1].split(/\s*,\s*/).map(function(e){var t=e.split(".");if(t.length===1&&t.indexOf("this")===-1){return e}if(e==="this"){return n}var r=t.indexOf("dataset")===1?Object.assign({},n.dataset):null;return r?r[t[2]]:n[t[1]]},n);return t}var m=Object.freeze({registerEventDelegator:u,delegateEvent:f,bubbleUntilActionFound:c,getComponentHtmlTarget:l,getEventActionFromElement:d,extractActionName:s,extractArguments:v});var p=window.DOMParser&&new window.DOMParser;var h="HTML";var y=false;var g=false;var b="text/html";var w="application/xhtml+xml";var E="<br/>";/* istanbul ignore next: Fails in older browsers */
try{
// Check if browser supports text/html DOMParser
if(p.parseFromString(E,b))y=true}catch(e){var x=document.implementation.createHTMLDocument("");var O=x.documentElement;var j=x.body;try{
// Check if browser supports documentElement.innerHTML
O.innerHTML+="";g=true}catch(e){
// Check if browser supports xhtml parsing.
p.parseFromString(E,w);var C=/(<body[^>]*>)([\s\S]*)<\/body>/}}/**
 * Returns the results of a DOMParser as an HTMLElement.
 * (Shims for older browsers).
 */
var S=y?function e(n,t){var r=p.parseFromString(n,b);return t===h?r.documentElement:r.body.firstChild}:function e(n,t){
// Fallback to innerHTML for other older browsers.
if(t===h){if(g){O.innerHTML=n;return O}else{
// IE9 does not support innerhtml at root level.
// We get around this by parsing everything except the body as xhtml.
var r=n.match(C);if(r){var o=r[2];var i=r.index+r[1].length;var a=i+o.length;n=n.slice(0,i)+n.slice(a);j.innerHTML=o}var u=p.parseFromString(n,w);var f=u.body;while(j.firstChild)f.appendChild(j.firstChild);return u.documentElement}}else{j.innerHTML=n;return j.firstChild}};D.KEY="data-key";D.IGNORE="data-ignore";D.CHECKSUM="data-checksum";var A=S;var N="_set-dom-";var _=N+"mounted";var T=1;var M=9;var P=11;
// Expose api.
var H=D;/**
 * @description
 * Updates existing dom to match a new dom.
 *
 * @param {Node} oldNode - The html entity to update.
 * @param {String|Node} newNode - The updated html(entity).
 */
function D(e,n){
// Ensure a realish dom node is provided.
V(e&&e.nodeType,"You must provide a valid node to update.");
// Alias document element with document.
if(e.nodeType===M)e=e.documentElement;
// Document Fragments don't have attributes, so no need to look at checksums, ignored, attributes, or node replacement.
if(n.nodeType===P){
// Simply update all children (and subchildren).
k(e,n)}else{
// Otherwise we diff the entire old node.
I(e,typeof n==="string"?A(n,e.nodeName):n)}
// Trigger mount events on initial set.
if(!e[_]){e[_]=true;Y(e)}}/**
 * @private
 * @description
 * Updates a specific htmlNode and does whatever it takes to convert it to another one.
 *
 * @param {Node} oldNode - The previous HTMLNode.
 * @param {Node} newNode - The updated HTMLNode.
 */
function I(e,n){if(e.nodeType===n.nodeType){
// Handle regular element node updates.
if(e.nodeType===T){
// Checks if nodes are equal before diffing.
if(F(e,n))return;
// Update all children (and subchildren).
k(e,n);
// Update the elements attributes / tagName.
if(e.nodeName===n.nodeName){
// If we have the same nodename then we can directly update the attributes.
L(e.attributes,n.attributes)}else{
// Otherwise clone the new node to use as the existing node.
var t=n.cloneNode();
// Copy over all existing children from the original node.
while(e.firstChild)t.appendChild(e.firstChild);
// Replace the original node with the new one with the right tag.
e.parentNode.replaceChild(t,e)}}else{
// Handle other types of node updates (text/comments/etc).
// If both are the same type of node we can update directly.
if(e.nodeValue!==n.nodeValue){e.nodeValue=n.nodeValue}}}else{
// we have to replace the node.
e.parentNode.replaceChild(n,U(e));Y(n)}}/**
 * @private
 * @description
 * Utility that will update one list of attributes to match another.
 *
 * @param {NamedNodeMap} oldAttributes - The previous attributes.
 * @param {NamedNodeMap} newAttributes - The updated attributes.
 */
function L(e,n){var t,r,o,i,a;
// Remove old attributes.
for(t=e.length;t--;){r=e[t];i=r.namespaceURI;a=r.localName;o=n.getNamedItemNS(i,a);if(!o)e.removeNamedItemNS(i,a)}
// Set new attributes.
for(t=n.length;t--;){r=n[t];i=r.namespaceURI;a=r.localName;o=e.getNamedItemNS(i,a);if(!o){
// Add a new attribute.
n.removeNamedItemNS(i,a);e.setNamedItemNS(r)}else if(o.value!==r.value){
// Update existing attribute.
o.value=r.value}}}/**
 * @private
 * @description
 * Utility that will nodes childern to match another nodes children.
 *
 * @param {Node} oldParent - The existing parent node.
 * @param {Node} newParent - The new parent node.
 */
function k(e,n){var t,r,o,i,a,u;var f=e.firstChild;var c=n.firstChild;var l=0;
// Extract keyed nodes from previous children and keep track of total count.
while(f){l++;t=f;r=R(t);f=f.nextSibling;if(r){if(!u)u={};u[r]=t}}
// Loop over new nodes and perform updates.
f=e.firstChild;while(c){l--;o=c;c=c.nextSibling;if(u&&(i=R(o))&&(a=u[i])){delete u[i];
// If we have a key and it existed before we move the previous node to the new position if needed and diff it.
if(a!==f){e.insertBefore(a,f)}else{f=f.nextSibling}I(a,o)}else if(f){t=f;f=f.nextSibling;if(R(t)){
// If the old child had a key we skip over it until the end.
e.insertBefore(o,t);Y(o)}else{
// Otherwise we diff the two non-keyed nodes.
I(t,o)}}else{
// Finally if there was no old node we add the new node.
e.appendChild(o);Y(o)}}
// Remove old keyed nodes.
for(r in u){l--;e.removeChild(U(u[r]))}
// If we have any remaining unkeyed nodes remove them from the end.
while(--l>=0){e.removeChild(U(e.lastChild))}}/**
 * @private
 * @description
 * Utility to try to pull a key out of an element.
 * Uses 'data-key' if possible and falls back to 'id'.
 *
 * @param {Node} node - The node to get the key for.
 * @return {string|void}
 */
function R(e){if(e.nodeType!==T)return;var n=e.getAttribute(D.KEY)||e.id;if(n)return N+n}/**
 * Checks if nodes are equal using the following by checking if
 * they are both ignored, have the same checksum, or have the
 * same contents.
 *
 * @param {Node} a - One of the nodes to compare.
 * @param {Node} b - Another node to compare.
 */
function F(e,n){
// Check if both nodes are ignored.
// Check if both nodes have the same checksum.
// Fall back to native isEqualNode check.
return B(e)&&B(n)||q(e)===q(n)||e.isEqualNode(n)}/**
 * @private
 * @description
 * Utility to try to pull a checksum attribute from an element.
 * Uses 'data-checksum' or user specified checksum property.
 *
 * @param {Node} node - The node to get the checksum for.
 * @return {string|NaN}
 */
function q(e){return e.getAttribute(D.CHECKSUM)||NaN}/**
 * @private
 * @description
 * Utility to try to check if an element should be ignored by the algorithm.
 * Uses 'data-ignore' or user specified ignore property.
 *
 * @param {Node} node - The node to check if it should be ignored.
 * @return {boolean}
 */
function B(e){return e.getAttribute(D.IGNORE)!=null}/**
 * Dispatches a mount event for the given node and children.
 *
 * @param {Node} node - the node to mount.
 * @return {node}
 */
function Y(e){return K(e,"mount")}/**
 * Dispatches a dismount event for the given node and children.
 *
 * @param {Node} node - the node to dismount.
 * @return {node}
 */
function U(e){return K(e,"dismount")}/**
 * Recursively trigger an event for a node and it's children.
 * Only emits events for keyed nodes.
 *
 * @param {Node} node - the initial node.
 * @return {Node}
 */
function K(e,n){
// Trigger event for this element if it has a key.
if(R(e)){var t=document.createEvent("Event");var r={value:e};t.initEvent(n,false,false);Object.defineProperty(t,"target",r);Object.defineProperty(t,"srcElement",r);e.dispatchEvent(t)}
// Dispatch to all children.
var o=e.firstChild;while(o)o=K(o,n).nextSibling;return e}/**
 * @private
 * @description
 * Confirm that a value is truthy, throws an error message otherwise.
 *
 * @param {*} val - the val to test.
 * @param {string} msg - the error message on failure.
 * @throws {Error}
 */
function V(e,n){if(!e)throw new Error("set-dom: "+n)}function G(e){return e&&e.__esModule?e["default"]:e}function z(e,n){return n={exports:{}},e(n,n.exports),n.exports}var W=z(function(e){var n=function(){"use strict";function e(e,n){return n!=null&&e instanceof n}var n;try{n=Map}catch(e){
// maybe a reference error because no `Map`. Give it a dummy value that no
// value will ever be an instanceof.
n=function(){}}var t;try{t=Set}catch(e){t=function(){}}var r;try{r=Promise}catch(e){r=function(){}}/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function o(i,a,u,f,l){if(typeof a==="object"){u=a.depth;f=a.prototype;l=a.includeNonEnumerable;a=a.circular}
// maintain two arrays for circular references, where corresponding parents
// and children have the same index
var d=[];var s=[];var v=typeof Buffer!="undefined";if(typeof a=="undefined")a=true;if(typeof u=="undefined")u=Infinity;
// recurse this function so we don't reset allParents and allChildren
function m(i,u){
// cloning null always returns null
if(i===null)return null;if(u===0)return i;var p;var h;if(typeof i!="object"){return i}if(e(i,n)){p=new n}else if(e(i,t)){p=new t}else if(e(i,r)){p=new r(function(e,n){i.then(function(n){e(m(n,u-1))},function(e){n(m(e,u-1))})})}else if(o.__isArray(i)){p=[]}else if(o.__isRegExp(i)){p=new RegExp(i.source,c(i));if(i.lastIndex)p.lastIndex=i.lastIndex}else if(o.__isDate(i)){p=new Date(i.getTime())}else if(v&&Buffer.isBuffer(i)){p=new Buffer(i.length);i.copy(p);return p}else if(e(i,Error)){p=Object.create(i)}else{if(typeof f=="undefined"){h=Object.getPrototypeOf(i);p=Object.create(h)}else{p=Object.create(f);h=f}}if(a){var y=d.indexOf(i);if(y!=-1){return s[y]}d.push(i);s.push(p)}if(e(i,n)){i.forEach(function(e,n){var t=m(n,u-1);var r=m(e,u-1);p.set(t,r)})}if(e(i,t)){i.forEach(function(e){var n=m(e,u-1);p.add(n)})}for(var g in i){var b;if(h){b=Object.getOwnPropertyDescriptor(h,g)}if(b&&b.set==null){continue}p[g]=m(i[g],u-1)}if(Object.getOwnPropertySymbols){var w=Object.getOwnPropertySymbols(i);for(var g=0;g<w.length;g++){
// Don't need to worry about cloning a symbol because it is a primitive,
// like a number or string.
var E=w[g];var x=Object.getOwnPropertyDescriptor(i,E);if(x&&!x.enumerable&&!l){continue}p[E]=m(i[E],u-1);if(!x.enumerable){Object.defineProperty(p,E,{enumerable:false})}}}if(l){var O=Object.getOwnPropertyNames(i);for(var g=0;g<O.length;g++){var j=O[g];var x=Object.getOwnPropertyDescriptor(i,j);if(x&&x.enumerable){continue}p[j]=m(i[j],u-1);Object.defineProperty(p,j,{enumerable:false})}}return p}return m(i,u)}/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
o.clonePrototype=function e(n){if(n===null)return null;var t=function(){};t.prototype=n;return new t};
// private utility functions
function i(e){return Object.prototype.toString.call(e)}o.__objToStr=i;function a(e){return typeof e==="object"&&i(e)==="[object Date]"}o.__isDate=a;function u(e){return typeof e==="object"&&i(e)==="[object Array]"}o.__isArray=u;function f(e){return typeof e==="object"&&i(e)==="[object RegExp]"}o.__isRegExp=f;function c(e){var n="";if(e.global)n+="g";if(e.ignoreCase)n+="i";if(e.multiline)n+="m";return n}o.__getRegExpFlags=c;return o}();if(typeof e==="object"&&e.exports){e.exports=n}});var J=z(function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});var t={"&":"&amp;",">":"&gt;","<":"&lt;",'"':"&quot;","'":"&#39;","`":"&#96;"};var r=new RegExp(Object.keys(t).join("|"),"g");n["default"]=function(){var e=arguments.length<=0||arguments[0]===undefined?"":arguments[0];return String(e).replace(r,function(e){return t[e]})};e.exports=n["default"]});var Q=G(J);
// Source: http://www.2ality.com/2015/01/template-strings-html.html#comment-2078932192
var X=function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),r=1;r<n;r++){t[r-1]=arguments[r]}return e.raw.reduce(function(e,n,r){var o=t[r-1];if(Array.isArray(o)){o=o.join("")}if(e.endsWith("@")){o=Q(o);e=e.slice(0,-1)}return e+o+n})};var Z=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol==="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function $(e,n){return e.then(function(e){if(e==null){throw new Error("No model received - aborting render")}n(e)}).catch(function(e){e=(typeof e==="undefined"?"undefined":Z(e))==="object"?e:e+"\r\nError unhandled by component. Add a catch handler in your action.";console.error(e);return e})}function ee(e,n){var t=e.next();if(t.value){if(t.value.then){$(t.value,n).then(function(){if(!t.done){ee(e,n)}})}else{n(t.value);if(!t.done){ee(e,n)}}}}function ne(e){if(e==null){throw new Error("InvalidArgument: DOM element expected")}return Array.prototype.map.call(e.querySelectorAll("[data-component]"),function(e){return e.getAttribute("data-component")})}var te={};function re(e,n,t,r){t(r);var o={};Object.keys(n).map(function(e){o[e]=function(){for(var o=arguments.length,i=Array(o),a=0;a<o;a++){i[a]=arguments[a]}var u=n[e].apply(n,i);if(u&&u.then){$(u,t)}if(u&&typeof u==="function"&&u().next){ee(u(),t)}t(r)}},this);o.name=e;o.get=function(e){return r[e]};o.render=function(){return t(r)};return o}function oe(e,n,t,r){if(e==null||e===""){throw new Error("Your component needs a name")}if(n==null){var o="// It must be a function that takes a model and returns an object of functions, e.g.\r\n\r\nYourComponent.Actions = function (model) {\r\n    return {\r\n        sayHello: function () { console.log('Hi.'); },\r\n        greet: function (name) { console.log('Hello, ' + name); }\r\n    }\r\n}";throw new Error(e+" needs some actions! Here's an example of an Actions function:\r\n\r\n"+o+"\r\n\r\n")}r=W(r);var i=t&&t();var a=i&&i.init?i.init:function(){};var u=i&&i.render?function(n){var t=i.render(n,X);if(typeof document!=="undefined"&&t){var r=document.querySelector("[data-component="+e+"]");if(r){if(r.innerHTML===""){r.innerHTML=t}else{H(r.firstElementChild,t)}var o=ne(r);if(o.length){o.map(function(e){return te[e]&&te[e].render()})}}}}:function(){};var f=re(e,n(r),u,r);te[e]=f;a(f,r);return f}if(typeof document!=="undefined"&&typeof m!=="undefined"){document.addEventListener("DOMContentLoaded",function(){u(te)})}var ie={components:te,create:oe};return ie});
//# sourceMappingURL=comp.min.js.map