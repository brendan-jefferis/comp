/* ____ ____ _  _ ___   
*  |___ [__] |\/| |--' . v1.4.1
* 
* A design pattern and micro-framework for creating UI components
*
* Copyright Brendan Jefferis and other contributors
* Released under the MIT license
* 
* Issues? Please visit https://github.com/brendan-jefferis/comp/issues
*
* Date: 2017-02-01T09:55:27.991Z 
*/
(function(e,n){typeof exports==="object"&&typeof module!=="undefined"?module.exports=n():typeof define==="function"&&define.amd?define(n):e.comp=n()})(this,function(){"use strict";function e(e){try{new Function(e)}catch(e){if(e instanceof SyntaxError){throw new SyntaxError(e)}}}function n(e){e=e||window.event;return e.target||e.srcElement}/* eslint-disable no-nested-ternary */
var t=[];var r=[];var o=function(e,n){if(e===n){return 0}var o=e.length;var i=n.length;if(o===0){return i}if(i===0){return o}var a;var u;var f;var c;var l=0;var d=0;while(l<o){r[l]=e.charCodeAt(l);t[l]=++l}while(d<i){a=n.charCodeAt(d);f=d++;u=d;for(l=0;l<o;l++){c=a===r[l]?f:f+1;f=t[l];u=t[l]=f>u?c>u?u+1:c:c>f?f+1:c}}return u};var i=3;function a(e,n){if(e==null){throw new Error("suggestActions requires a string argument to use as a query")}if(n==null){throw new Error("suggestActions requires a component to search for actions")}var t=[];Object.keys(n).map(function(n){var r=o(e,n);if(r>i){return}t.push({term:n,distance:r})});return t.sort(function(e,n){return e.distance>n.distance})}function u(e){Object.keys(Event.prototype).map(function(n,t){if(t>=10&&t<=19){document.body.addEventListener(n.toLowerCase(),function(n){f(n,e)})}},this)}function f(e,t){e.stopPropagation();var r=n(e);if(r.nodeName==="BODY"){return}var o=l(r);var i=t[o.getAttribute("data-component")];var u=d(e,r,o);if(u.name===""){return}if(i[u.name]==null){var f=a(u.name,i);var c=f.length?"\r\n\r\nDid you mean\r\n\r\n"+f.map(function(e){return i.name+"."+e.term+"\n"}).join("")+"\r":"";throw new Error("Could not find action "+u.name+" in component "+i.name+c)}if(u.args===""){i[u.name]()}else{i[u.name].apply(u,u.args)}}function c(n,t,r){var o=t.getAttribute("data-"+[n.type])||"";if(o!==""||t===r){try{e(o,t)}catch(e){var i=document.createElement("div");i.appendChild(t.cloneNode(false));throw new SyntaxError("\r\n\r\nElement: "+i.innerHTML+"\r\nEvent: data-"+[n.type]+"\r\nAction: "+o+"\r\n\r\n"+e)}return{name:o,element:t}}return c(n,t.parentNode,r)}function l(e){return e.closest("[data-component]")}function d(e,n,t){var r=c(e,n,t);return{name:s(r.name),args:m(r.name,r.element)}}function s(e){var n=e.match(/[^(]*/);return n?n[0]:""}function m(e,n){var t=/\(\s*([^)]+?)\s*\)/.exec(e);if(!t||t[1]==null){return""}t=t[1].split(/\s*,\s*/).map(function(e){var t=e.split(".");if(t.length===1&&t.indexOf("this")===-1){return e}var r=t.indexOf("dataset")===1?Object.assign({},n.dataset):null;return r?r[t[2]]:n[t[1]]},n);return t}var v=Object.freeze({registerEventDelegator:u,delegateEvent:f,bubbleUntilActionFound:c,getComponentHtmlTarget:l,getEventActionFromElement:d,extractActionName:s,extractArguments:m});var p=new window.DOMParser;var y="text/html";var g="application/xhtml+xml";var h="<i></i>";var b="HTML";var w=false;var E=false;
// Check if browser supports text/html DOMParser
try{/* istanbul ignore next: Fails in older browsers */
if(p.parseFromString(h,y))w=true}catch(e){}try{/* istanbul ignore next: Only used in ie9 */
if(!w&&p.parseFromString(h,g))E=true}catch(e){}/**
 * Returns the results of a DOMParser as an HTMLElement.
 * (Shims for older browser and IE9).
 */
var O=w?function e(n,t){var r=p.parseFromString(n,y);return t===b?r.documentElement:r.body.firstChild}:function e(n,t){var r=t===b;
// Special case for ie9 (documentElement.innerHTML not supported).
if(E&&r){return p.parseFromString(n,g).documentElement}
// Fallback to innerHTML for other older browsers.
var o=document.implementation.createHTMLDocument("");if(r){o.documentElement.innerHTML=n;return o.documentElement}else{o.body.innerHTML=n;return o.body.firstChild}};var j=O;var N="_set-dom-";var x=N+"index";var S=N+"mounted";var A=window.Node.ELEMENT_NODE;var C=window.Node.DOCUMENT_NODE;T.KEY="data-key";T.IGNORE="data-ignore";T.CHECKSUM="data-checksum";var _=T;/**
 * @description
 * Updates existing dom to match a new dom.
 *
 * @param {Node} prev - The html entity to update.
 * @param {String|Node} next - The updated html(entity).
 */
function T(e,n){
// Ensure a realish dom node is provided.
q(e&&e.nodeType,"You must provide a valid node to update.");
// Alias document element with document.
if(e.nodeType===C)e=e.documentElement;
// If a string was provided we will parse it as dom.
if(typeof n==="string")n=j(n,e.nodeName);
// Update the node.
D(e,n);
// Trigger mount events on initial set.
if(!e[S]){e[S]=true;R(e)}}/**
 * @private
 * @description
 * Updates a specific htmlNode and does whatever it takes to convert it to another one.
 *
 * @param {Node} prev - The previous HTMLNode.
 * @param {Node} next - The updated HTMLNode.
 */
function D(e,n){if(e.nodeType===n.nodeType){
// Handle regular element node updates.
if(e.nodeType===A){
// Ignore elements if their checksum matches.
if(k(e)===k(n))return;
// Ignore elements that explicity choose not to be diffed.
if(L(e)&&L(n))return;
// Update all children (and subchildren).
P(e,e.childNodes,n.childNodes);
// Update the elements attributes / tagName.
if(e.nodeName===n.nodeName){
// If we have the same nodename then we can directly update the attributes.
M(e,e.attributes,n.attributes)}else{
// Otherwise clone the new node to use as the existing node.
var t=n.cloneNode();
// Copy over all existing children from the original node.
while(e.firstChild)t.appendChild(e.firstChild);
// Replace the original node with the new one with the right tag.
e.parentNode.replaceChild(t,e)}}else{
// Handle other types of node updates (text/comments/etc).
// If both are the same type of node we can update directly.
if(e.nodeValue!==n.nodeValue){e.nodeValue=n.nodeValue}}}else{
// we have to replace the node.
F(e);e.parentNode.replaceChild(n,e);R(n)}}/**
 * @private
 * @description
 * Utility that will update one list of attributes to match another.
 *
 * @param {Node} parent - The current parentNode being updated.
 * @param {NamedNodeMap} prev - The previous attributes.
 * @param {NamedNodeMap} next - The updated attributes.
 */
function M(e,n,t){var r,o,i,a,u;
// Remove old attributes.
for(r=n.length;r--;){o=n[r];a=o.namespaceURI;u=o.localName;i=t.getNamedItemNS(a,u);if(!i)n.removeNamedItemNS(a,u)}
// Set new attributes.
for(r=t.length;r--;){o=t[r];a=o.namespaceURI;u=o.localName;i=n.getNamedItemNS(a,u);if(!i){
// Add a new attribute.
t.removeNamedItemNS(a,u);n.setNamedItemNS(o)}else if(i.value!==o.value){
// Update existing attribute.
i.value=o.value}}}/**
 * @private
 * @description
 * Utility that will update one list of childNodes to match another.
 *
 * @param {Node} parent - The current parentNode being updated.
 * @param {NodeList} prevChildNodes - The previous children.
 * @param {NodeList} nextChildNodes - The updated children.
 */
function P(e,n,t){var r,o,i,a,u;
// Convert nodelists into a usuable map.
var f=I(n);var c=I(t);
// Remove old nodes.
for(r in f){if(c[r])continue;
// Trigger custom dismount event.
F(f[r]);
// Remove child from dom.
e.removeChild(f[r])}
// Set new nodes.
for(r in c){o=f[r];i=c[r];
// Extract the position of the new node.
a=i[x];if(o){
// Update an existing node.
D(o,i);
// Check if the node has moved in the tree.
if(o[x]===a)continue;
// Get the current element at the new position.
/* istanbul ignore next */
u=n[a]||null;// TODO: figure out if || null is needed.
// Check if the node has already been properly positioned.
if(u===o)continue;
// Reposition node.
e.insertBefore(o,u)}else{
// Get the current element at the new position.
u=n[a]||null;
// Append the new node at the correct position.
e.insertBefore(i,u);
// Trigger custom mounted event.
R(i)}}}/**
 * @private
 * @description
 * Converts a nodelist into a keyed map.
 * This is used for diffing while keeping elements with 'data-key' or 'id' if possible.
 *
 * @param {NodeList} childNodes - The childNodes to convert.
 * @return {Object}
 */
function I(e){var n={};var t=e.length;var r;for(var o=0;o<t;o++){r=e[o];r[x]=o;n[H(r)||o]=r}return n}/**
 * @private
 * @description
 * Utility to try to pull a key out of an element.
 * Uses 'data-key' if possible and falls back to 'id'.
 *
 * @param {Node} node - The node to get the key for.
 * @return {String}
 */
function H(e){if(e.nodeType!==A)return;var n=e.getAttribute(T.KEY)||e.id;if(n)n=N+n;return n&&N+n}/**
 * @private
 * @description
 * Utility to try to pull a checksum attribute from an element.
 * Uses 'data-checksum' or user specified checksum property.
 *
 * @param {Node} node - The node to get the checksum for.
 * @return {String|NaN}
 */
function k(e){return e.getAttribute(T.CHECKSUM)||NaN}/**
 * @private
 * @description
 * Utility to try to check if an element should be ignored by the algorithm.
 * Uses 'data-ignore' or user specified ignore property.
 *
 * @param {Node} node - The node to check if it should be ignored.
 * @return {Boolean}
 */
function L(e){return e.getAttribute(T.IGNORE)!=null}/**
 * Recursively trigger a mount event for a node and it's children.
 *
 * @param {Node} node - the initial node to be mounted.
 */
function R(e){
// Trigger mount event for this element if it has a key.
if(H(e))B(e,"mount");
// Mount all children.
var n=e.firstChild;while(n){R(n);n=n.nextSibling}}/**
 * Recursively trigger a dismount event for a node and it's children.
 *
 * @param {Node} node - the initial node to be dismounted.
 */
function F(e){
// Dismount all children.
var n=e.firstChild;while(n){F(n);n=n.nextSibling}
// Trigger dismount event for this element if it has a key.
if(H(e))B(e,"dismount")}/**
 * @private
 * @description
 * Create and dispatch a custom event.
 *
 * @param {Node} el - the node to dispatch the event for.
 * @param {String} type - the name of the event.
 */
function B(e,n){var t=document.createEvent("Event");var r={value:e};t.initEvent(n,false,false);Object.defineProperty(t,"target",r);Object.defineProperty(t,"srcElement",r);e.dispatchEvent(t)}/**
 * @private
 * @description
 * Confirm that a value is truthy, throws an error message otherwise.
 *
 * @param {*} val - the val to test.
 * @param {String} msg - the error message on failure.
 * @throws Error
 */
function q(e,n){if(!e)throw new Error("set-dom: "+n)}function U(e){return e&&e.__esModule?e["default"]:e}function Y(e,n){return n={exports:{}},e(n,n.exports),n.exports}var K=Y(function(e){var n=function(){"use strict";var e;try{e=Map}catch(n){
// maybe a reference error because no `Map`. Give it a dummy value that no
// value will ever be an instanceof.
e=function(){}}var n;try{n=Set}catch(e){n=function(){}}var t;try{t=Promise}catch(e){t=function(){}}/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function r(o,i,a,u,c){if(typeof i==="object"){a=i.depth;u=i.prototype;c=i.includeNonEnumerable;i=i.circular}
// maintain two arrays for circular references, where corresponding parents
// and children have the same index
var l=[];var d=[];var s=typeof Buffer!="undefined";if(typeof i=="undefined")i=true;if(typeof a=="undefined")a=Infinity;
// recurse this function so we don't reset allParents and allChildren
function m(o,a){
// cloning null always returns null
if(o===null)return null;if(a===0)return o;var v;var p;if(typeof o!="object"){return o}if(o instanceof e){v=new e}else if(o instanceof n){v=new n}else if(o instanceof t){v=new t(function(e,n){o.then(function(n){e(m(n,a-1))},function(e){n(m(e,a-1))})})}else if(r.__isArray(o)){v=[]}else if(r.__isRegExp(o)){v=new RegExp(o.source,f(o));if(o.lastIndex)v.lastIndex=o.lastIndex}else if(r.__isDate(o)){v=new Date(o.getTime())}else if(s&&Buffer.isBuffer(o)){v=new Buffer(o.length);o.copy(v);return v}else if(o instanceof Error){v=Object.create(o)}else{if(typeof u=="undefined"){p=Object.getPrototypeOf(o);v=Object.create(p)}else{v=Object.create(u);p=u}}if(i){var y=l.indexOf(o);if(y!=-1){return d[y]}l.push(o);d.push(v)}if(o instanceof e){var g=o.keys();while(true){var h=g.next();if(h.done){break}var b=m(h.value,a-1);var w=m(o.get(h.value),a-1);v.set(b,w)}}if(o instanceof n){var E=o.keys();while(true){var h=E.next();if(h.done){break}var O=m(h.value,a-1);v.add(O)}}for(var j in o){var N;if(p){N=Object.getOwnPropertyDescriptor(p,j)}if(N&&N.set==null){continue}v[j]=m(o[j],a-1)}if(Object.getOwnPropertySymbols){var x=Object.getOwnPropertySymbols(o);for(var j=0;j<x.length;j++){
// Don't need to worry about cloning a symbol because it is a primitive,
// like a number or string.
var S=x[j];var A=Object.getOwnPropertyDescriptor(o,S);if(A&&!A.enumerable&&!c){continue}v[S]=m(o[S],a-1);if(!A.enumerable){Object.defineProperty(v,S,{enumerable:false})}}}if(c){var C=Object.getOwnPropertyNames(o);for(var j=0;j<C.length;j++){var _=C[j];var A=Object.getOwnPropertyDescriptor(o,_);if(A&&A.enumerable){continue}v[_]=m(o[_],a-1);Object.defineProperty(v,_,{enumerable:false})}}return v}return m(o,a)}/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
r.clonePrototype=function e(n){if(n===null)return null;var t=function(){};t.prototype=n;return new t};
// private utility functions
function o(e){return Object.prototype.toString.call(e)}r.__objToStr=o;function i(e){return typeof e==="object"&&o(e)==="[object Date]"}r.__isDate=i;function a(e){return typeof e==="object"&&o(e)==="[object Array]"}r.__isArray=a;function u(e){return typeof e==="object"&&o(e)==="[object RegExp]"}r.__isRegExp=u;function f(e){var n="";if(e.global)n+="g";if(e.ignoreCase)n+="i";if(e.multiline)n+="m";return n}r.__getRegExpFlags=f;return r}();if(typeof e==="object"&&e.exports){e.exports=n}});var V=Y(function(e,n){"use strict";Object.defineProperty(n,"__esModule",{value:true});var t={"&":"&amp;",">":"&gt;","<":"&lt;",'"':"&quot;","'":"&#39;","`":"&#96;"};var r=new RegExp(Object.keys(t).join("|"),"g");n["default"]=function(){var e=arguments.length<=0||arguments[0]===undefined?"":arguments[0];return String(e).replace(r,function(e){return t[e]})};e.exports=n["default"]});var G=U(V);
// Source: http://www.2ality.com/2015/01/template-strings-html.html#comment-2078932192
var z=function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),r=1;r<n;r++){t[r-1]=arguments[r]}return e.raw.reduce(function(e,n,r){var o=t[r-1];if(Array.isArray(o)){o=o.join("")}if(e.endsWith("@")){o=G(o);e=e.slice(0,-1)}return e+o+n})};var W=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(e){return typeof e}:function(e){return e&&typeof Symbol==="function"&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function J(e,n){return e.then(function(e){if(e==null){throw new Error("No model received - aborting render")}n(e)}).catch(function(e){e=(typeof e==="undefined"?"undefined":W(e))==="object"?e:e+"\r\nError unhandled by component. Add a catch handler in your action.";console.error(e);return e})}function Q(e){if(e==null){throw new Error("InvalidArgument: DOM element expected")}return Array.prototype.map.call(e.querySelectorAll("[data-component]"),function(e){return e.getAttribute("data-component")})}var X={};function Z(e,n,t,r){t(r);var o={};Object.keys(n).map(function(e){o[e]=function(){for(var o=arguments.length,i=Array(o),a=0;a<o;a++){i[a]=arguments[a]}var u=n[e].apply(n,i);if(u&&u.then){J(u,t)}t(r)}},this);o.name=e;o.get=function(e){return r[e]};o.render=function(){return t(r)};return o}function $(e,n,t,r){if(e==null||e===""){throw new Error("Your component needs a name")}if(n==null){var o="// It must be a function that takes a model and returns an object of functions, e.g.\r\n\r\nYourComponent.Actions = function (model) {\r\n    return {\r\n        sayHello: function () { console.log('Hi.'); },\r\n        greet: function (name) { console.log('Hello, ' + name); }\r\n    }\r\n}";throw new Error(e+" needs some actions! Here's an example of an Actions function:\r\n\r\n"+o+"\r\n\r\n")}r=K(r);var i=t&&t();var a=i&&i.init?i.init:function(){};var u=i&&i.render?function(n){var t=i.render(n,z);if(typeof document!=="undefined"&&t){var r=document.querySelector("[data-component="+e+"]");if(r){if(r.innerHTML===""){r.innerHTML=t}else{_(r.firstElementChild,t)}var o=Q(r);if(o.length){o.map(function(e){return X[e]&&X[e].render()})}}}}:function(){};var f=Z(e,n(r),u,r);X[e]=f;a(f,r);return f}if(typeof document!=="undefined"&&typeof v!=="undefined"){u(X)}var ee={components:X,create:$};return ee});
//# sourceMappingURL=comp.min.js.map